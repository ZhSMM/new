# 多线程实践

## 实践策略

1. 挖掘出程序的可并发点--------实现多线程目标并发计算的前提；
2. 实现并发化的策略：
   - 基于数据的分割策略：从程序处理的数据入手，将原始输入分解成若干规模更小的子输入，并将这些子输入指派给专门的工作线程；
   - 基于任务的分割策略：从程序处理逻辑入手，将原始任务处理逻辑按照**任务的资源消耗属性**或者**处理步骤分解**为若干子任务，并创建专门的工作者线程来执行这些子任务，其结果是产生多个相互协作的异质工作线程。
3. 注意事项：
   - 多线程比相应单线程复杂，且未必有单线程快；
   - 线程数的合理设置：
     - Amdahl's定律
     - 处理器数目
     - 任务性质：IO密集/处理器密集
     - 资源使用规划
     - 稀缺资源使用情况
   - 更快的代价：额外的开销；
   - 工作者线程异常处理；
   - 原始规模未知问题的应对；

## 线程间协作

### 等待与通知

> 在单线程编程中，程序目标动作需要满足一定条件才执行时可以将该动作放入if语句体中；在多线程中，该条件未满足有可能只是暂时的，我们可以等待其他线程更新了保护条件涉及的共享变量而得以执行。因此，我们可以将当前线程暂停，直到所需要的保护条件成立时才唤醒。

```java
// 原子操作
atomic{
    while(保护条件不成立){
        // 暂停当前线程
    }
    // 执行目标动作
    doAction();
}
```

**等待**：一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程叫等待；

**唤醒**：一个线程更新了系统的状态，使得其他线程所需的保护线程得以满足的时候唤醒那些暂停的线程的过程叫通知。

等待线程执行：Object.wait()/wait(long)

通知线程执行：Object.notify()/notifyAll()

伪代码示意：

```java
// 使用Object.wait()实现等待
// 在调用wait方法前获得相应的内部锁
// 受保护方法：保护条件、暂停当前线程和目标动作
synchronized(someObject){
    while(保护条件不成立){
        // 调用Object.wait()暂停当前线程
        someObject.wait();
    }
    // 代码执行到此说明保护条件已满足
    // 执行目标动作
    doAction();
}

// 注意：
// 1.等待线程对保护条件的判断、Object.wait()的调用总
//  是应该放在相应对象所引导的临界区中的一个循环语句之中；
// 2.等待线程对保护条件的判断、Object.wait()的执行以及
//  目标动作的执行必须放在同一个对象（内部锁）所引导的临界区中。
// 3.Object.wait()暂停当前线程时释放的锁只是与该wait
//  方法所属对象的内部锁。当前线程所持有的其他内部锁、显示
//  锁不会因此被释放。
```

```java
// 通知方法：更新共享变量、唤醒其他线程
synchronized(someObject){
    // 更新等待线程的保护条件涉及的共享变量
    updateSharedState();
    // 唤醒其他线程
    someObject.notify();
}
// 注意：等待线程和通知线程必须调用同一个对象的wait方法、
// notify方法来实现等待和通知。调用一个对象的notify方法
// 所唤醒的线程仅是该对象上的一个任意等待线程。notify方法
// 调用应尽可能的放在靠近临界区结束的地方。
```

**等待线程**：someObject为java任意类实例，因执行someObject.wait()而被暂停的线程就称为对象someObject的等待线程。

- 同一对象可能有多个等待线程；
- 其他线程可以通过someObject.notify()来唤醒等待线程；







开销及问题：

- 使用Condition接口
  - 过早唤醒
  - Object.wait(long)无法区分其返回是否是等待超时导致；
- 将等待线程对保护条件的判断、Object..wait()的调用放在相应对象所引导的临界区中的一个循环语句中；
  - 信号丢失问题
  - 欺骗性唤醒问题
- 确保正确性的前提下用Object.notify()代替Object.notifyAll()，通知线程尽快释放锁；
  - 较多的上下文切换

Java条件变量：

- 为规避过早唤醒问题提供支持：使用不同保护条件的等待线程调用不同的条件变量await方法来实现其等待。