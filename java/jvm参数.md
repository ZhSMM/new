# jvm参数

## 堆大小设置

JVM 中最大堆大小有三方面限制: 

1. 相关操作系统的数据模型(32-bt还是64-bit)限制; 
2. 系统的可用虚拟内存限制; 
3. 系统的可用物理内存限制。 在32位系统下，可控内存4GB，操作系统会给予一个限制，一般Windows限制在1.5G~2G，Linux限制2g-3g；64为操作系统对内存无特定限制。

java整个堆的大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64M，增大年轻代后会减小老年代的大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。（注：这里默认的使用的JVM是Sun的Hotspot，而其中使用GC算法就是分代算法。）

java参数：

- -Xmx2M：设置JVM最大可用内存2M；

- -Xms2M：设置JVM初始内存2M，与-Xmx相同是避免每次垃圾回收完成后JVM内存的重新分配；

- -Xmn1M：设置年轻代大小为1M；

  -  -XX:MinHeapFreeRatio=40：如果发现空闲堆内存占到整个预估上限值的40%，则增大上限值；
  - -XX:MaxHeapFreeRatio=70：如果发现空闲堆内存占到整个预估上限值的70%，则收缩预估上限值；

  - -XX:NewRatio=4：设置年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)；设置为4，则年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5；
  - -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6；
  - -XX:TargetSurvivorRatio=50：实际使用的survivor 空间大小占比。默认是47%，最高90%。
  - -XX:PermSize：设置非堆内存（持久代、方法区）初始值，默认物理内存1/16；
  - -XX:MaxPermSize=256m：设置最大非堆内存（持久代、方法区），默认物理内存1/4；
  - -XX:MaxTenuringThreshold=0：设置垃圾最大年龄，默认15；
    - 如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代；
    - 对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率；

- -Xss128k：设置每个线程的堆栈大小。

  - JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为128k。更具应用的线程所需内存大小进行调整。
  - 在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成。

## 回收器选择

JVM回收器：串行收集器，并行收集器，并行压缩收集器，CMS 收集器，G1收集器。并行被并行压缩收集器所替代，CMS 收集器被G1收集器替代。

**串行收集器(Serial Collector)**：

- 在同一时间只会执行一件垃圾清理任务，非常适用于单线程，单CPU 架构的程序，串行收集器的开销也比较小，在老年代中使用mark-sweep-compact(标记—扫描-压缩)算法， 对于堆内存不是很大的程序比较适用。
- 串行收集器适用场景：客户端程序(-client)和单线程比较小的应用。可以声明-XX:+UseSerialGC 选项使用串行收集器。

**并行压缩收集器(Parallel Compacting Collector)**：

- 并行压缩收集器是在J2SE1.5后引入，与并行收集器(并行收集器又被称作吞吐量收集器)最大的不同是对老年代的回收使用了不同的算法，并行压缩收集器最终会取代并行收集器。并行压缩收集器最大的优点就是在消耗部分硬件性能及多CPU 支持下可以做到更短的stop-the-world 暂停，使回收效率更高从而增加了程序的吞吐量。
- 并行压缩收集器适用场景：程序稳定长期运行，希望任何时候我们的程序都能得到响应，即使程序执行速度缓慢，例如一些后台程序。硬件水平较高，例如多CPU，多物理内存的服务器可以选择并行压缩收集器。可以声明-XX:+UseParallelOldGC 选项使用并行压缩收集器。

**CMS 收集器(Concurrent Mark-Sweep (CMS) Collector)**：

- 在很多应用中，更加注重快速的相应时间而不是吞吐量。新生代的垃圾回收通常不会造成长时间的应用程序中断，但是，对于老年代，特别是当Heap  已使用量比较大的时候会导致长时间的程序中断(虽然这种情况不常发生)。Hotspot JVM 引入CMS 的目的就是为了解决这个问题。
- CMS 收集器适用场景(G1同理)：对于老年代使用率比较高的应用程序适合CMS  收集器，对停顿时间有较严格要求的程序也比较适合使用CMS 收集器。所以CMS  收集器多用于应用服务器程序上，例如web系统等。这类系统的共同特点就是响应时间一般较短，否则容易造成用户体验差的评价。可以声明-xx:+UseConcMarkSweepGC 选项使用CMS。如果你还想让CMS 运行与增量模式下，则可声明–XX:+CMSIncrementalMode  选项启用增量模式。增量模式指的是把收集器的工作分成多个时间块，然后在两次新生代的回收期间加以运行，这种方式可以更进一步减少暂停的时间。

收集器设置：

- -XX:+UseSerialGC：使用串行收集器
- -XX:+UseParallelGC：使用并行收集器
- -XX:+UseParalledlOldGC：使用并行压缩收集器 
- -XX:+UseConcMarkSweepGC：使用CMS 收集器

优化设置：

- -XX:-DisableExplicitGC：禁止在运行期显式地调用System.gc()，开启该选项后，GC 的触发时机将由Garbage Collector 全权掌控，默认：关闭。
- -XX:+ScavengeBeforeFullGC：在Full GC前触发一次Minor GC，默认：启用。
- -XX:+UseGCOverheadLimit：限制GC的运行时间。如果GC耗时过长，就抛OutOfMemoryError。
- -XX:ParallelGCThreads=n：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。
- -XX:+UseTLAB：启用线程本地缓存区(Thread Local)。

垃圾回收统计信息：

- -XX:+PrintGC ：开启GC日志打印；
- -XX:+PrintGCDetails ：打印GC回收的详细信息；
- -XX:+PrintGCTimeStamps ：打印GC停顿耗时；
- -Xloggc:filename：输出GC 详细日志信息至指定文件；
- -XX:+UseGCLogFileRotation：开启GC 日志文件切分功能，前置选项 -Xloggc；
- -XX:NumberOfGClogFiles=1：设置切分GC 日志文件数量，文件命名格式：.0, .1, ..., .n-1；
- -XX:GCLogFileSize=8K：GC日志文件切分大小；

并行收集器设置：

- -XX:ParallelGCThreads=n：设置并行收集器收集时使用的CPU数，并行收集线程数；
- -XX:MaxGCPauseMillis=n：设置并行收集最大暂停时间
- -XX:GCTimeRatio=n：设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)

并发收集器设置：

- -XX:+CMSIncrementalMode：设置为增量模式，适用于单CPU情况；
- -XX:ParallelGCThreads=n：设置并发收集器年轻代收集方式为并行收集时，使用的CPU数，并行收集线程数；

G1收集器设置：

- -XX:+UseG1GC：使用G1收集器。
- -XX:MaxGCPauseMillis=n：设置并行收集最大暂停时间，这是一个理想目标，JVM 将尽最大努力来实现它。

年轻代大小选择：

- 响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制(根据实际情况选择)。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象；
- 吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

年老代大小选择：

- 响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可能会造成内存碎片，高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：
  - 并发垃圾收集信息 
  - 持久代并发收集次数 
  - 传统GC信息 
  - 花在年轻代和年老代回收上的时间比例
  - 减少年轻代和年老代花费的时间,一般会提高应用的效率
- 吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。

较小堆引起的碎片问题：

因为年老代的并发收集器使用**标记-清除算法**，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现"碎片"，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记-清除方式进行回收。如果出现"碎片"，可能需要进行如下配置： 

- -XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩；
- -XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩；